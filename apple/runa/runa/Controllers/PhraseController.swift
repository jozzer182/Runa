//
//  PhraseController.swift
//  runa
//
//  Created by JOSE ZARABANDA on 7/30/25.
//

import Foundation
import Combine

@MainActor
class PhraseController: ObservableObject {
    static let shared = PhraseController()
    
    @Published var currentPhrase: Phrase?
    @Published var isLoading = false
    @Published var errorMessage: String?
    @Published var connectionStatus: ConnectionStatus = .unknown
    @Published var lastUpdateTime: Date?
    @Published var totalPhrasesCount = 0
    
    private let realmService = RealmService.shared
    private let firestoreService = FirestoreService.shared
    private let geminiService = GeminiService.shared
    
    private var cancellables = Set<AnyCancellable>()
    
    enum ConnectionStatus {
        case unknown
        case online
        case offline
        case limited // Gemini quota exceeded but Firestore available
    }
    
    private init() {
        setupPeriodicUpdates()
    }
    
    func initialize() async {
        isLoading = true
        errorMessage = nil
        
        print("🚀 Starting PhraseController initialization...")
        
        do {
            // Inicializar Realm
            print("📱 Initializing Realm...")
            try await realmService.initialize()
            updateTotalPhrasesCount()
            print("✅ Realm initialized successfully - Total phrases: \(totalPhrasesCount)")
            
            // Inicializar Firebase AI Logic (Gemini) - no crítico si falla
            do {
                print("🧠 Initializing Gemini...")
                try await geminiService.initialize()
                print("✅ Gemini initialized successfully")
            } catch {
                print("⚠️ Gemini initialization failed: \(error.localizedDescription)")
                // No es crítico, la app puede funcionar sin Gemini
            }
            
            // Cargar frase inicial
            print("📝 Loading today's phrase...")
            await loadTodaysPhrase()
            
        } catch {
            errorMessage = "Error al inicializar la aplicación: \(error.localizedDescription)"
            print("❌ Initialization error: \(error)")
            
            // Intentar cargar al menos una frase básica
            if let fallbackPhrase = createFallbackPhrase() {
                currentPhrase = fallbackPhrase
                print("🆘 Using fallback phrase: \(fallbackPhrase.text)")
            }
        }
        
        isLoading = false
        print("🏁 PhraseController initialization completed")
    }
    
    private func createFallbackPhrase() -> Phrase? {
        let phrase = Phrase()
        phrase.id = 999
        phrase.text = "Bienvenido a Runa. Tu dosis diaria de motivación."
        phrase.source = "fallback"
        phrase.createdAt = Date()
        return phrase
    }
    
    func loadTodaysPhrase() async {
        isLoading = true
        errorMessage = nil
        
        print("📝 Starting to load today's phrase...")
        
        // Intentar obtener una nueva frase siguiendo la jerarquía
        await tryGetNewPhrase()
        
        isLoading = false
        lastUpdateTime = Date()
        
        if let phrase = currentPhrase {
            print("✅ Today's phrase loaded: \(phrase.text)")
        } else {
            print("❌ Failed to load any phrase")
        }
    }
    
    private func tryGetNewPhrase() async {
        print("🔍 Trying to get new phrase - following hierarchy...")
        
        // 1. Intentar obtener frase de Gemini
        do {
            print("🧠 Attempting to get phrase from Gemini...")
            let newPhrase = try await geminiService.createPhraseFromGemini()
            
            // Guardar en Realm
            try await realmService.addPhraseAsync(newPhrase)
            
            // Crear una copia de los datos para Firestore para evitar problemas de threading
            let phraseData = PhraseData(
                id: newPhrase.id,
                text: newPhrase.text,
                createdAt: newPhrase.createdAt,
                source: newPhrase.source,
                isShown: newPhrase.isShown,
                lastShownAt: newPhrase.lastShownAt
            )
            
            // Intentar guardar en Firestore (no crítico si falla)
            try? await firestoreService.savePhraseData(phraseData)
            
            currentPhrase = newPhrase
            connectionStatus = .online
            updateTotalPhrasesCount()
            
            print("✅ New phrase generated by Gemini: \(newPhrase.text)")
            return
            
        } catch GeminiError.quotaExceeded {
            print("⚠️ Gemini quota exceeded, trying Firestore...")
            connectionStatus = .limited
        } catch {
            print("❌ Gemini error: \(error)")
        }
        
        // 2. Intentar obtener frase aleatoria de Firestore
        do {
            print("☁️ Attempting to get phrase from Firestore...")
            if let firestorePhrase = try await firestoreService.getRandomPhrase() {
                currentPhrase = firestorePhrase
                
                // Marcar como mostrada en Realm si existe
                if let localPhrase = realmService.getAllPhrases()?.filter("id == %@", firestorePhrase.id).first {
                    try? await realmService.markPhraseAsShownAsync(localPhrase)
                }
                
                connectionStatus = connectionStatus == .limited ? .limited : .online
                print("✅ Phrase loaded from Firestore: \(firestorePhrase.text)")
                return
            }
        } catch {
            print("❌ Firestore error: \(error)")
        }
        
        // 3. Obtener frase local de Realm
        print("💾 Attempting to get phrase from local Realm...")
        if let localPhrase = realmService.getRandomUnshownPhrase() {
            do {
                try await realmService.markPhraseAsShownAsync(localPhrase)
                currentPhrase = localPhrase
                connectionStatus = .offline
                print("✅ Phrase loaded from Realm: \(localPhrase.text)")
                return
            } catch {
                print("❌ Error marking phrase as shown: \(error)")
            }
        } else {
            print("⚠️ No unshown phrases found in Realm")
        }
        
        // 4. Si todo falla, usar frase de emergencia
        print("🆘 All sources failed, using fallback phrase...")
        if let fallbackPhrase = createFallbackPhrase() {
            currentPhrase = fallbackPhrase
            connectionStatus = .offline
            print("✅ Using fallback phrase: \(fallbackPhrase.text)")
            return
        }
        
        // 5. Último recurso - mensaje de error
        errorMessage = "No se pudieron cargar frases. Se actualizarán en próximos días."
        connectionStatus = .offline
        print("❌ All phrase sources failed, including fallback")
    }
    
    func forceRefreshPhrase() async {
        await loadTodaysPhrase()
    }
    
    func checkConnectivity() async {
        let geminiStatus = await geminiService.isGeminiAvailable()
        let firestoreStatus = await firestoreService.checkConnection()
        
        if geminiStatus && firestoreStatus {
            connectionStatus = .online
        } else if firestoreStatus {
            connectionStatus = .limited
        } else {
            connectionStatus = .offline
        }
    }
    
    private func updateTotalPhrasesCount() {
        totalPhrasesCount = realmService.getPhrasesCount()
    }
    
    private func setupPeriodicUpdates() {
        // Actualizar cada 24 horas
        Timer.publish(every: 24 * 60 * 60, on: .main, in: .common)
            .autoconnect()
            .sink { [weak self] _ in
                Task {
                    await self?.loadTodaysPhrase()
                }
            }
            .store(in: &cancellables)
    }
    
    // MARK: - Helper Functions
    
    func getConnectionStatusText() -> String {
        switch connectionStatus {
        case .unknown:
            return "Verificando conexión..."
        case .online:
            return "Conectado"
        case .offline:
            return "Sin conexión"
        case .limited:
            return "Conexión limitada"
        }
    }
    
    func getConnectionStatusColor() -> String {
        switch connectionStatus {
        case .unknown:
            return "gray"
        case .online:
            return "green"
        case .offline:
            return "red"
        case .limited:
            return "orange"
        }
    }
    
    func canRefresh() -> Bool {
        return !isLoading
    }
}
