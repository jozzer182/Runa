//
//  PhraseController.swift
//  runa
//
//  Created by JOSE ZARABANDA on 7/30/25.
//

import Foundation
import Combine

@MainActor
class PhraseController: ObservableObject {
    static let shared = PhraseController()
    
    @Published var currentPhrase: Phrase?
    @Published var isLoading = false
    @Published var errorMessage: String?
    @Published var connectionStatus: ConnectionStatus = .unknown
    @Published var lastUpdateTime: Date?
    @Published var totalPhrasesCount = 0
    
    private let realmService = RealmService.shared
    private let firestoreService = FirestoreService.shared
    private let geminiService = GeminiService.shared
    private let widgetDataService = WidgetDataService.shared
    
    private var cancellables = Set<AnyCancellable>()
    
    enum ConnectionStatus {
        case unknown
        case online
        case offline
        case limited // Gemini quota exceeded but Firestore available
    }
    
    private init() {
        setupPeriodicUpdates()
    }
    
    func initialize() async {
        isLoading = true
        errorMessage = nil
        
        print("üöÄ Starting PhraseController initialization...")
        
        do {
            // Inicializar Realm
            print("üì± Initializing Realm...")
            try await realmService.initialize()
            updateTotalPhrasesCount()
            print("‚úÖ Realm initialized successfully - Total phrases: \(totalPhrasesCount)")
            
            // Inicializar Firebase AI Logic (Gemini) - no cr√≠tico si falla
            do {
                print("üß† Initializing Gemini...")
                try await geminiService.initialize()
                print("‚úÖ Gemini initialized successfully")
            } catch {
                print("‚ö†Ô∏è Gemini initialization failed: \(error.localizedDescription)")
                // No es cr√≠tico, la app puede funcionar sin Gemini
            }
            
            // Cargar frase inicial
            print("üìù Loading today's phrase...")
            await loadTodaysPhrase()
            
            // Actualizar datos del widget
            await updateWidgetDataAsync()
            
        } catch {
            errorMessage = "Error al inicializar la aplicaci√≥n: \(error.localizedDescription)"
            print("‚ùå Initialization error: \(error)")
            
            // Intentar cargar al menos una frase b√°sica
            if let fallbackPhrase = createFallbackPhrase() {
                currentPhrase = fallbackPhrase
                print("üÜò Using fallback phrase: \(fallbackPhrase.text)")
            }
        }
        
        isLoading = false
        print("üèÅ PhraseController initialization completed")
    }
    
    private func createFallbackPhrase() -> Phrase? {
        let phrase = Phrase()
        phrase.id = 999
        phrase.text = "Bienvenido a Runa. Tu dosis diaria de motivaci√≥n."
        phrase.source = "fallback"
        phrase.createdAt = Date()
        return phrase
    }
    
    func loadTodaysPhrase() async {
        isLoading = true
        errorMessage = nil
        
        print("üìù Starting to load today's phrase...")
        
        // Intentar obtener una nueva frase siguiendo la jerarqu√≠a
        await tryGetNewPhrase()
        
        isLoading = false
        lastUpdateTime = Date()
        
        if let phrase = currentPhrase {
            print("‚úÖ Today's phrase loaded: \(phrase.text)")
        } else {
            print("‚ùå Failed to load any phrase")
        }
    }
    
    private func tryGetNewPhrase() async {
        print("üîç Trying to get new phrase - following hierarchy...")
        
        // 1. Intentar obtener frase de Gemini
        do {
            print("üß† Attempting to get phrase from Gemini...")
            let newPhrase = try await geminiService.createPhraseFromGemini()
            
            // Guardar en Realm
            try await realmService.addPhraseAsync(newPhrase)
            
            // Crear una copia de los datos para Firestore para evitar problemas de threading
            let phraseData = PhraseData(
                id: newPhrase.id,
                text: newPhrase.text,
                createdAt: newPhrase.createdAt,
                source: newPhrase.source,
                isShown: newPhrase.isShown,
                lastShownAt: newPhrase.lastShownAt
            )
            
            // Intentar guardar en Firestore (no cr√≠tico si falla)
            try? await firestoreService.savePhraseData(phraseData)
            
            currentPhrase = newPhrase
            connectionStatus = .online
            updateTotalPhrasesCount()
            
            // Actualizar widget con la nueva frase
            updateWidgetData()
            
            print("‚úÖ New phrase generated by Gemini: \(newPhrase.text)")
            return
            
        } catch GeminiError.quotaExceeded {
            print("‚ö†Ô∏è Gemini quota exceeded, trying Firestore...")
            connectionStatus = .limited
        } catch {
            print("‚ùå Gemini error: \(error)")
        }
        
        // 2. Intentar obtener frase aleatoria de Firestore
        do {
            print("‚òÅÔ∏è Attempting to get phrase from Firestore...")
            if let firestorePhrase = try await firestoreService.getRandomPhrase() {
                currentPhrase = firestorePhrase
                
                // Marcar como mostrada en Realm si existe
                if let localPhrase = realmService.getAllPhrases()?.filter("id == %@", firestorePhrase.id).first {
                    try? await realmService.markPhraseAsShownAsync(localPhrase)
                }
                
                connectionStatus = connectionStatus == .limited ? .limited : .online
                
                // Actualizar widget
                updateWidgetData()
                
                print("‚úÖ Phrase loaded from Firestore: \(firestorePhrase.text)")
                return
            }
        } catch {
            print("‚ùå Firestore error: \(error)")
        }
        
        // 3. Obtener frase local de Realm
        print("üíæ Attempting to get phrase from local Realm...")
        if let localPhrase = realmService.getRandomUnshownPhrase() {
            do {
                try await realmService.markPhraseAsShownAsync(localPhrase)
                currentPhrase = localPhrase
                connectionStatus = .offline
                
                // Actualizar widget
                updateWidgetData()
                
                print("‚úÖ Phrase loaded from Realm: \(localPhrase.text)")
                return
            } catch {
                print("‚ùå Error marking phrase as shown: \(error)")
            }
        } else {
            print("‚ö†Ô∏è No unshown phrases found in Realm")
        }
        
        // 4. Si todo falla, usar frase de emergencia
        print("üÜò All sources failed, using fallback phrase...")
        if let fallbackPhrase = createFallbackPhrase() {
            currentPhrase = fallbackPhrase
            connectionStatus = .offline
            print("‚úÖ Using fallback phrase: \(fallbackPhrase.text)")
            return
        }
        
        // 5. √öltimo recurso - mensaje de error
        errorMessage = "No se pudieron cargar frases. Se actualizar√°n en pr√≥ximos d√≠as."
        connectionStatus = .offline
        print("‚ùå All phrase sources failed, including fallback")
    }
    
    func forceRefreshPhrase() async {
        await loadTodaysPhrase()
    }
    
    func checkConnectivity() async {
        let geminiStatus = await geminiService.isGeminiAvailable()
        let firestoreStatus = await firestoreService.checkConnection()
        
        if geminiStatus && firestoreStatus {
            connectionStatus = .online
        } else if firestoreStatus {
            connectionStatus = .limited
        } else {
            connectionStatus = .offline
        }
    }
    
    private func updateTotalPhrasesCount() {
        totalPhrasesCount = realmService.getPhrasesCount()
    }
    
    private func setupPeriodicUpdates() {
        // Actualizar cada 24 horas
        Timer.publish(every: 24 * 60 * 60, on: .main, in: .common)
            .autoconnect()
            .sink { [weak self] _ in
                Task {
                    await self?.loadTodaysPhrase()
                }
            }
            .store(in: &cancellables)
    }
    
    // MARK: - Helper Functions
    
    func getConnectionStatusText() -> String {
        switch connectionStatus {
        case .unknown:
            return "Verificando conexi√≥n..."
        case .online:
            return "Conectado"
        case .offline:
            return "Sin conexi√≥n"
        case .limited:
            return "Conexi√≥n limitada"
        }
    }
    
    func getConnectionStatusColor() -> String {
        switch connectionStatus {
        case .unknown:
            return "gray"
        case .online:
            return "green"
        case .offline:
            return "red"
        case .limited:
            return "orange"
        }
    }
    
    func canRefresh() -> Bool {
        return !isLoading
    }
    
    // MARK: - Widget Integration
    
    private func updateWidgetData() {
        Task {
            await updateWidgetDataAsync()
        }
    }
    
    @MainActor
    private func updateWidgetDataAsync() async {
        // Obtener todas las frases disponibles para el widget
        guard let allPhrases = realmService.getAllPhrases() else {
            print("‚ùå No se pudieron obtener frases para el widget")
            return
        }
        
        let phraseTexts = widgetDataService.validateAndPreparePhrasesForWidget(from: Array(allPhrases))
        
        // Actualizar datos del widget
        let currentPhraseText = currentPhrase?.text
        widgetDataService.updateWidgetData(phrases: phraseTexts, currentPhrase: currentPhraseText)
        
        print("‚úÖ Widget data updated with \(phraseTexts.count) phrases")
    }
    
    func refreshWidgetData() {
        updateWidgetData()
    }
}
